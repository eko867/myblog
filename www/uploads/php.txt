быстрое форматирование с помощью сочетания CTRL+ALT+L

динамическая типизация" – одна и та же переменная может хранить значения разных типов. 
интерпретация (что смог, то посчитал, иначе отбросил и пошел дальше)
внутри одинарных кавычек нету поиска переменных/при использовании одинарных кавычек работа со строками будет происходить быстрее, так как не будет парсинга
вывести значение переменной и при этом использовать одинарные кавычки, можно склеить строки. Этот приём называется конкатенацией строк
тип, который получится в результате какого-либо выражения, будет зависеть от оператора / в зависимости от оператора, операнды будут сначала приведены к нужному типу, а затем над ними будет выполнена операция
В результате использования оператора ТОЧКА всегда получится строка. (число+строка=строка)
при использовании оператора ПЛЮС, всегда будет получаться число. (число+строка=число)
Приведение типа можно сделать и самостоятельно (int) / (float) / (string) / (boolean) / (array) / (object) 
еще есть тип resource (файл, БД, ...)
приведение строки идет по первым цифрам (до первой буквы)('10.68ards403.3'=10.68   'fds54'-будет игнор))
функция var_dump($variableName) - показывает тип переменной (+длину для строки) и ее значение
** оператор возведения в степень
% остаток от деления
/ деление (вернет int или float)
' ' или " " для задания строки без разницы
+= -= *= /= .= разрешены
== приводит операнды к одному типу и после сравнивает их значения ('2' равно 2) / аналогично !=
=== не выполняет приведения типов и сравнивает сначала то, что типы значений идентичны, например int, а затем сравнивает их значения / аналогично !==
<=> - оператор spaceship / $a <=> $b       Если $a > $b, вернёт 1    Если $a == $b, вернёт 0   Если $a < $b, вернёт -1   (да хоть даже так 'bc'<=>'bb')

$i++ - постфиксный инкремент, возвращает текущее значение $i, а затем увеличивает значение на единицу
$i-- - постфиксный декремент, возвращает текущее значение $i, а затем уменьшает значение на единицу
++$i – префиксный инкремент, сначала увеличивает значение переменной $i на единицу, а затем возвращает результат
--$i – префиксный декремент, сначала уменьшает значение переменной $i на единицу, а затем возвращает результат
(для цикла пофигу $i++ или ++$i - есть инкремент, а возращаемое значение никуда не пишется , но для $x=$i++ и $х=++$i уже есть разница)


&& - логическое И, вернёт true, только если оба операнда истинны (true)
|| - логическое ИЛИ, вернёт true, если хотя бы один из операндов является истинным
! – ОТРИЦАНИЕ, возвращает true, если операнд – false, и наоборот. Применяется если нужно инвертировать условие, зачастую это очень кстати.
xor – исключающее ИЛИ, вернёт true, только если один из операторов true, а другой – false
если операнды не являются булевыми значениями, они будут автоматически приведены к true или false(если это '' или 0 или '0')

if-else можно сократить (тернарный оператор)	$variable= условие ? результат_если_true : результат_если_false
$a= $b<$c ? $b : $c; 

switch 
break прерывает набор условий, не забывайте указывать его;
секция default будет выполнена, если не выполнилось ни одно из условий. Она может и вовсе отсутствовать;
несколько case-ов могуть быть записаны подряд (case 1: case 2: [че будет делаться] break;) , тогда код в секции выыполнится при выполнении хотя бы одного из условий.

$b=&$a; - b ссылка на переменную a (если a изменится, то  и значение b поменяется + даже если b изменится, то  и значение a поменяется)(a и b теперь привязаны к одной ячейке памяти)
передача переменной: по значению: function func($x) / по ссылке: function func(&$x)
разрешен type hinting (function getSum(int $x, int $y)) то есть указывать тип переменных в сигнатуре (к этому типу они и будут автоприродиться) / еще перед сигнатурой можно сделать жесткую типизацию declare(strict_types=[номер аргумента]); - теперь если подан аргумент не того типа, автоприведения не будет и стрельнет ошибка

если подключаемый файл не найден, то при include возникнет warning, но программа продолжит своё выполнение.(использовать для файлов, которые необязательно должны быть подключены)(например баннерная реклама)
если подключаемого не окажется при попытке выполнить require, то произойдёт фатальная ошибка и скрипт завершит свою работу.(использовать там, где подключение файла обязательно)
можно сделать $x=include 'file.php'; ($x cтанет равным 1 при успешном включении, 0 при неуспешном, или со значением return (если таков был в 'file.php'))

count($arr)
array_key_exist($key,$array) - есть ли элемент с индексом key
in_array($needle,$array) - есть ли элемент со значением needle
$arrNew=array_merge($arr1,$arr2) - слияние (массивы с числовыми индексами сольются последовательно, с буквенными индексами при пересечении будет перезапись и останется лишь из $arr2)

метод передачи из хтмл форму через GET - это формирование запроса в адресной строке (к URL-адресу прицепляется аргументы и их значения)(на странице куда ведет URL-адрес c пом.PHP сервером идет извлечение этих значений из массива $_GET[] и дальнейший препроцессинг)
(это быстро и просто, но небезопасно передавать конф.инф. через адресную строку -> могут подсмотреть)(подразумевают использ.там, где ссылкой можно поделиться и чтобы формы уже были заполнены)
POST - всё тот же запрос от клиента к серверу, только параметры передаются внутри тела запроса, а не в адресной строке(не в query параметрах). И увидеть их просто так не получится.(браузер д.б. в режиме разработчика)

переданный логин и пароль не позволит создать сессию между нами и сервером. То есть сервер не может нас «запомнить»
и каждый раз, как мы хотим сказать что это мы, придется отправлять отдельный новый запрос с логином и паролем. В качестве решения придумали cookie.
это с типом ключ-значение,хранятся они в браузере у пользователя. Для каждого сайта cookie хранятся отдельно.
Каждый раз, когда пользователь обращается с запросом на сайт, браузер проверяет наличие этих записей для данного сайта. И если они имеются, то он отправляет их в заголовке каждого запроса к этому сайту.

Cookie создаются в фоне в браузере по «просьбе» сервера. В какой-то момент мы решаем, что нужно в браузере посетителя создать cookie с каким-то значением + временем жизни(задается в секундах, но есть заеб).
Для этого нужно чтобы сервер передал в ответе клиенту специальный заголовок, в котором указано, какую запись нужно создать в браузере для данного сайта.
функция setcookie и любые другие функции в PHP, изменяющие заголовок в HTTP-ответе, должны вызываться до любого вывода данных (ротокол HTTP устроен таким образом, что заголовок должен всегда идти перед данными, и никак иначе)

чтобы куки встали нормально есть функция header
При использовании функции header() для редиректа внешних ссылок большое значение имеет место расположения ее вызова. В коде он должен находиться выше всех тегов html:

Сейчас в PHP для хеширования следует использовать функцию password_hash(), а для проверки хеша - password_verify(). Если вы в каком-то уроке увидите, что для хеширования паролей используется md5 - бегите оттуда, такие хеши вскрываются за несколько минут, она устарела ещё лет 10 назад.


