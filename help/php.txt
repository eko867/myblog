быстрое форматирование с помощью сочетания CTRL+ALT+L

В основе решения всевозможных задач лежит использование языка HTML для создания форм ввода данных, языка PHP — для обработки данных, а сервера базы данных — для хранения данных.

динамическая типизация – одна и та же переменная может хранить значения разных типов. 
интерпретация (что смог, то посчитал, иначе отбросил и пошел дальше)
внутри одинарных кавычек нету поиска переменных/при использовании одинарных кавычек работа со строками будет происходить быстрее, так как не будет парсинга
вывести значение переменной и при этом использовать одинарные кавычки, можно склеить строки через конкатенацию
тип, который получится в результате какого-либо выражения, будет зависеть от оператора / в зависимости от оператора, операнды будут сначала приведены к нужному типу, а затем над ними будет выполнена операция
В результате использования оператора ТОЧКА всегда получится строка. (число+строка=строка)
при использовании оператора ПЛЮС, всегда будет получаться число. (число+строка=число)
Приведение типа можно сделать и самостоятельно (int) / (float) / (string) / (boolean) / (array) / (object) 
еще есть тип resource (файл, БД, ...)
приведение строки идет по первым цифрам (до первой буквы)('10.68ards403.3'=10.68   'fds54'-будет игнор))
функция var_dump($variableName) - показывает тип переменной (+длину имени у строки) и ее значение
** оператор возведения в степень
% остаток от деления
/ деление (вернет int или float)
' ' или " " для задания строки без разницы
+= -= *= /= .= разрешены
== приводит операнды к одному типу и после сравнивает их значения ('2' равно 2) / аналогично !=
=== не выполняет приведения типов и сравнивает сначала то, что типы значений идентичны, например int, а затем сравнивает их значения / аналогично !==
<=> - оператор spaceship / $a <=> $b       Если $a > $b, вернёт 1    Если $a == $b, вернёт 0   Если $a < $b, вернёт -1   (да хоть даже так 'bc'<=>'bb')

$i++ - постфиксный инкремент, возвращает текущее значение $i, а затем увеличивает значение на единицу
$i-- - постфиксный декремент, возвращает текущее значение $i, а затем уменьшает значение на единицу
++$i – префиксный инкремент, сначала увеличивает значение переменной $i на единицу, а затем возвращает результат
--$i – префиксный декремент, сначала уменьшает значение переменной $i на единицу, а затем возвращает результат
(для цикла пофигу $i++ или ++$i - есть инкремент, а возращаемое значение никуда не пишется , но для $x=$i++ и $х=++$i уже есть разница)


&& - логическое И, вернёт true, только если оба операнда истинны
|| - логическое ИЛИ, вернёт true, если хотя бы один из операндов является истинным
! – ОТРИЦАНИЕ, возвращает true, если операнд – false, и наоборот. Применяется если нужно инвертировать условие, зачастую это очень кстати.
xor – исключающее ИЛИ, вернёт true, только если один из операторов true, а другой – false
если операнды не являются булевыми значениями, они будут автоматически приведены к true или false(если это '' или 0 или '0')

if-else можно сократить (тернарный оператор)	$variable= условие ? результат_если_true : результат_если_false
$a= $b<$c ? $b : $c; 

switch 
break прерывает набор условий, не забывайте указывать его;
секция default будет выполнена, если не выполнилось ни одно из условий. Она может и вовсе отсутствовать;
несколько case-ов могуть быть записаны подряд (case 1: case 2: [че будет делаться] break;) , тогда код в секции выыполнится при выполнении хотя бы одного из условий.

$b=&$a; - b ссылка на переменную a (если a изменится, то  и значение b поменяется + даже если b изменится, то  и значение a поменяется)(a и b теперь привязаны к одной ячейке памяти)
передача переменной: по значению: function func($x) / по ссылке: function func(&$x)
разрешен type hinting (function getSum(int $x, int $y) :?array) то есть указывать тип переменных в сигнатуре (к этому типу они и будут автоприродиться) / еще перед сигнатурой можно сделать жесткую типизацию declare(strict_types=[номер аргумента]); - теперь если подан аргумент не того типа, автоприведения не будет и стрельнет ошибка

если подключаемый файл не найден, то при include возникнет warning, но программа продолжит своё выполнение.(использовать для файлов, которые необязательно должны быть подключены)(например баннерная реклама)
если подключаемого не окажется при попытке выполнить require, то произойдёт фатальная ошибка и скрипт завершит свою работу.(использовать там, где подключение файла обязательно)
можно сделать $x=include 'file.php'; ($x cтанет равным 1 при успешном включении, 0 при неуспешном, или со значением return (если таков был в 'file.php'))

count($arr)
array_key_exist($key,$array) - есть ли элемент с индексом key
in_array($needle,$array) - есть ли элемент со значением needle
$arrNew=array_merge($arr1,$arr2) - слияние (массивы с числовыми индексами сольются последовательно, с буквенными индексами при пересечении будет перезапись и останется лишь из $arr2)

метод передачи из хтмл форму через GET - это формирование запроса в адресной строке (к URL-адресу прицепляется аргументы и их значения)(на странице куда ведет URL-адрес c пом.PHP сервером идет извлечение этих значений из массива $_GET[] и дальнейший препроцессинг)
(это быстро и просто, но небезопасно передавать конф.инф. через адресную строку -> могут подсмотреть)(подразумевают использ.там, где ссылкой можно поделиться и чтобы формы уже были заполнены)
POST - всё тот же запрос от клиента к серверу, только параметры передаются внутри тела запроса, а не в адресной строке(не в query параметрах). И увидеть их просто так не получится.(браузер д.б. в режиме разработчика)

переданный логин и пароль не позволит создать сессию между нами и сервером. То есть сервер не может нас «запомнить»
и каждый раз, как мы хотим сказать что это мы, придется отправлять отдельный новый запрос с логином и паролем. В качестве решения придумали cookie.
это с типом ключ-значение,хранятся они в браузере у пользователя. Для каждого сайта cookie хранятся отдельно.
Каждый раз, когда пользователь обращается с запросом на сайт, браузер проверяет наличие этих записей для данного сайта. И если они имеются, то он отправляет их в заголовке каждого запроса к этому сайту.

Cookie создаются в фоне в браузере по «просьбе» сервера. В какой-то момент мы решаем, что нужно в браузере посетителя создать cookie с каким-то значением + временем жизни(задается в секундах, но есть заеб).
Для этого нужно чтобы сервер передал в ответе клиенту специальный заголовок, в котором указано, какую запись нужно создать в браузере для данного сайта.
функция setcookie и любые другие функции в PHP, изменяющие заголовок в HTTP-ответе, должны вызываться до любого вывода данных (ротокол HTTP устроен таким образом, что заголовок должен всегда идти перед данными, и никак иначе)

чтобы куки встали нормально есть функция header
При использовании функции header() для редиректа внешних ссылок большое значение имеет место расположения ее вызова. В коде он должен находиться выше всех тегов html:

Сейчас в PHP для хеширования следует использовать функцию password_hash(), а для проверки хеша - password_verify(). Если вы в каком-то уроке увидите, что для хеширования паролей используется md5 - бегите оттуда, такие хеши вскрываются за несколько минут, она устарела ещё лет 10 назад.

start transaction; commit / rollback ;
Транзакции требуются тогда, когда нужно чтобы несколько запросов точно применились и выполнились все друг за друом, либо не выполнился ни один из них, если что-то пойдёт не так.
(пример оплата на сайте)(заказ, списание денег у покупателя, подтверждение заказа) 

Неважно, насколько простые или сложные у вас сценарии, если они общаются с базой данных, они начинаются с одних и тех же нескольких действий:
Подключение к установленной субд MySQL (даже если БД еще нет, а только имя-пароль).
Использование команды USE в отношении нужной базы данных MySQL.
Отправка SQL query базе данных.
Получение результатов.
Обработка результатов.

Для подключения к базе данных мы будем использовать PDO - PHP Data Objects. При его использовании можно не бояться SQL-инъекций, это возможно благодаря подготовленным параметрам, но об этом чуть позже.
Это важно! Если в интернете вы найдёте урок, где будет использоваться mysqli_connect или mysql_connect - смело закрывайте его, так писали 10 лет назад.

Защита от SQL-ннъекций
Всегда используйте PDO и биндинг значений, это не позволит прокинуть что-либо опасное в ваш SQL-запрос. Не пихайте данные напрямую в запрос

Защита от PHP-инъекций
Можно придумать кучу разных фильтраций. Но я бы посоветовал придерживаться правила – не допускать попадания данных от пользователя в include, require, eval.

Защита от XSS-атак(злоумышленник в текст комментария может попросту вставить в тексте код на JavaScript)
htmlentities()

Еще использовать заголовки Content Security Policy. Если вкратце – они позволяют ограничить ресурсы, к которым разрешаются разного типа запросы. Можно указать откуда можно использовать ресурсы. 
ЕЩе Валидация(проверка на корректность) и санитация данных(приведение к единому образцу)

Шифрование и хеширование (Md5 устарел, радужные таблицы, даже с солью быстро ломается) => работай с passwordhash() и passwordverify() (встроенная соль и соврем.алгоритмы)

ИНКАПСУЛЯЦИЯ (все свойства-поля и методы-функции собраны в классе как в капсуле)
Модификаторы доступа public/protected(как private но разрешает наследование)/private
переменная $this
конструктор public function __construct

НАСЛЕДОВАНИЕ (возможность повторно использовать код) extends (наследуется только public или protected)
переопределение методов получается обычным написанием фукнции с тем же именем
parent::[метод] - вызывает родительский метод (даже если было переопределение)

констансты приндалежат классу, можно обратиться внутри класса через self::[NAME] или во вне через NameOfClass::[NAME] 
полезная вещь self::class (имя класса)

ИНТЕРФЕЙСЫ - Это такие «контракты», которые класс должен соблюдать, если он на это «подписался»/ Интерфейс – это описание public методов, которые представляют собой только название метода, описание их аргументов и возвращаемый тип. Тело метода в интерфейсе не описывается.
когда требуется проверить, что перед нами экземпляр какого-то класса  либо что этот объект реализует какой-то интерфейс - используется конструкция instanceof (возращает true/false)
объекты дочерних классов будут проходить проверку на то, что они являются экземплярами родительских классов.
строка с именем класса можно узнать через get_class()

АБСТРАКТНЫЕ КЛАССЫ (abstract  class ...)
это лишь объявление методов (abstract public function ...) + мб уже готовые методы ( public function...), которые должны быть реализованы в дочерних классах / Создать объект абстрактного класса нельзя – от него можно только наследоваться. 

ПОЛИМОРФИЗМ (возможность абстракций и интерфейсов)
oбъекты, реализовавшие какой-то интерфейс обязательно будут иметь метод с определённым набором параметров. 
То есть мы можем рассчитывать на то, что этот метод у объекта гарантированно есть и мы можем его вызвать.
и мы можем зависеть не от конкретной реализации (проще говоря конкретного класса), а от абстракции (интерфейса)

Перегрузка методов? - функции с одинаковым именем писать нельзя
1извращение - опциональные операторы+значения по умолчанию    public function __construct(int $a=null, int $b=null, int $c=null){ if (isset...) ... else ...}      $a=new A(null,$b);  //$a=null, $b, $c=null
2извращение - использование функций количества аргументов функции при ее вызове func_num_args() и их значения func_get_arg($num) //отсчет аргументов ведется с нуля.
3извращение - уйти от перегрузки конструкторов через использование статичных функций public static function creatorWithOneParam(int $c){ return new self(0,0,$c);}
(в пхп под перегрузкой понимают какую-то весчь с магическими функциями _get, _set,_call, _invoke...)

trait – это такой механизм (взамен наследования, когда оно невозможно), который позволяет внутри классов избегать повторного написания кода.
несколько классов ничем несвязанных имеют одинаковый функционал -> выносим его в трейт trait A{ public function ...} , а в классах используем use A;
часто требования прописаны в интерфейсе, реализация вынесена в трейт, а затем классы реализуют интерфейс простым use...


Порой приходится в классе хранить информацию, которая будет использоваться всеми объектами, или будет говорить что-то общее обо всех объектах. Например, можно сделать счётчик созданных объектов внутри класса.
static - свойства и методы, которые принадлежат классу целиком, а не созданным объектам этого класса. То есть использовать их можно даже без создания объектов (NameOfClass::method/$value)(так же они доступны и объектам класса ExampleOfClass::method/$value)
С помощью статического метода мы можем создать объекты этого класса, с указанием каких-либо значений по умолчанию. Cтатический метод, порождающий объекты, становится изящным способом упростить код
в статических методах нет слова $this (объекта нет – нет и $this, ведь $this указывает на объект класса)
внутри класса мы сможем достучаться до статических свойств, при помощи слова self::

namespace MyProject\Models\Users; (вначале без слеша)
класс можно поместить в отдельное именованное пространство и в дальнейшем использовать его по этому полному имени
типа был $a=new User(), а стал  $a=new \MyProject\Models\Users\User() (вначале со слешем)       либо use MyProject\Models\Users\User;   $a=new User();


MVC (разделение логики приложения и представление данных)
Model - бизнес-логика приложения+работа с БД+CRUD-операции, источник данных и функций/ слой приложения, отвечающий за работу с данными
Controller – это точка входа в наше приложение + логика того, что вообще нужно сделать. Контроллер работает с моделями и передаёт результат во View. (по сути это класс с методом(-ами), публичные методы контроллера ещё называются actions)
View(представление) - что видит пользователь 

Регулярные выражения - это механизм для поиска и замены в строках по маскам
поиска по регуляркам - preg_match('/pattern/', 'string where search', $array_with_mathces)



ДЛЯ ДОБАВЛЕНИЯ НОВОЙ СТРАНИЧКИ

Добавляем экшн в контроллер (либо создаём ещё и новый контроллер c компонентом private $view );
Добавляем роут в routes.php, регулярку для его отлова и контроллер; (ключи массива - регулярка для отлова ЧПУ, значения массива - новый масссив с названием класса контроллера и названием метода)
Описываем логику внутри экшена и в конце вызываем у компонента view метод renderHtml(на какой шаблон, с каким массивом переменных);
Создаём шаблон для вывода результата

ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ Приложений
1) концепция ORM 
Таблица базы данных или представление обёрнуты в классы. Таким образом, объектный экземпляр привязан к единственной строке в таблице. 
После создания объекта новая строка будет добавляться к таблице на сохранение. Любой загруженный объект получает свою информацию от базы данных. 
Когда объект обновлён, соответствующая строка в таблице также будет обновлена. 
Класс обёртки реализует методы средства доступа или свойства для каждого столбца в таблице или представлении.

ее реализует паттерн Active Record - говорит о том, что объекты класса сами должны управлять работой с базой данных. 
весь остальной код, который эти сущности использует, не должен знать о базе данных. Наши контроллеры не должны работать с базой данных, получая данные и заполняя ими сущности. 
одна из идей в том, чтобы обратиться к сущности, не создавая ее (за счет статических методов), и попросить вернуть уже заполненную сущность (напрмимер, $article=Article::getArticleById($id); )
Они должны знать только о сущностях. Сущность сама должна позаботиться о работе с базой данных.


2) Singleton паттерн говорит о том, что в рамках одного запущенного приложения будет гарантироваться что будет использован только один объект какого-то класса. 
Классы, реализующие паттерн синглтон сами гарантируют, что будет использоваться только один их экземпляр – создать объекты можно только с помощью специального метода, ведь конструктор private и больше недоступен извне.
А этот метод следит за тем, чтобы не было более одного созданного объекта и предоставляет единую точку доступа к этому экземпляру.


PHP Reflection API (прога делает самоанализ и меняет свое поведение, рефлексирует)
влиять на программу в процессе ее выполнения можно например через:
языковые конструкции self и static / магические константы __DIR__ и __CLASS__ / функции get_defined_vars(), func_get_args() или eval()
создание объекта класса по значению переменной $obj=new $stringWithClassName(); или вызвать метод по значению переменной $obj->$stringWithMethodName();
PHP Reflection API – это набор специальных классов-рефлекторов, позволяющих вывести рефлексию на новый уровень
а) класс-рефлектор для функций — $fReflector = new ReflectionFunction('functionName') //его методы позволяют узнать файл и строки, где описана функция, можно вывести комментарий о функции в формате PHPDoc
б) класс-рефлектор для объектов - $objReflector = new \ReflectionObject($obj); //его методы позволяют узнать все свойства, методы, константы объекта, еще дают создать новый объект (даже с private конструктром или вовсе без него)


CRUD (Create/Read/Update/Delete)
При работе с базами данных практически любое приложение должно поддерживать эти операции.
В MySQL им соответсвуют INSERT/SELECT/UPDATE/DELETE => эти операции реализованы в нашем приложении в классе ActiveRecordEntity


CGI(Common gateway interface) 
интерфейс, позволяющий пользователю отправлять запросы на сервер (GET, POST, FILE, через формы и тп.) посредством формирования заголовков (headers) для дальнейших сценариев
а серверу присылать свои ответы
